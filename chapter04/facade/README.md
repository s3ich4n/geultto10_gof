# FAÇADE

# Intent

하위 시스템에 있는 인터페이스 집합에 통합된 인터페이스를 제공

Facade는 하위 시스템을 더 쉽게 사용할 수 있도록 상위 수준의 인터페이스를 정의

# aka.

# Motivation

시스템을 하위 시스템으로 구조화하면 복잡성을 줄이는 데 도움됨
일반적인 설계 목표는 하위 시스템 간의 통신과 의존성을 최소화하는 것
이 목표를 달성하는 한 가지 방법은 하위 시스템의 더 일반적인 기능에 대해 단일하고 단순화된 인터페이스를 제공하는 퍼사드(facade) 객체를 도입

- 단순화된 인터페이스 제공: 복잡한 하위 시스템의 기능을 사용하기 쉬운 단일 인터페이스로 제공합니다.
- 복잡성 감소: 시스템을 하위 시스템으로 구조화하여 전체 시스템의 복잡성을 줄입니다.
- 의존성 최소화: 하위 시스템 간의 통신과 의존성을 최소화합니다.
- 유연성 유지: 필요한 경우, 고급 사용자가 하위 시스템의 세부 기능에 직접 접근할 수 있도록 합니다.

책의 컴파일러 예시:

- `Compiler` 클래스는 Facade로 작동
- 대부분의 사용자가 복잡한 컴파일러 구성 요소(`Scanner`, `Parser` 등)의 세부 사항을 알 필요 없이 컴파일 기능을 사용가능

# Applicability

Facade 패턴을 사용해야 하는 상황:

1. 복잡한 하위 시스템의 단순화
    - 복잡한 하위 시스템에 대해 대부분의 클라이언트에게 적합한 간단한 인터페이스 제공
    - 특별한 커스터마이징이 필요한 클라이언트만 더 깊게 접근
2. 의존성 감소
    - 클라이언트와 구현 클래스 사이의 많은 의존성을 제거
    - 하위 시스템의 독립성과 이식성 향상
3. 시스템 계층화:
    - 각 하위 시스템 계층에 대한 명확한 진입점 정의
    - 하위 시스템 간 통신을 Facade를 통해서만 이루어지게 함으로써 의존성 단순화

이 패턴은 특히 시스템이 발전하면서 더 복잡해질 때 유용

# Structure

![refactoring.guru의 Façade 예시](https://refactoring.guru/images/patterns/diagrams/facade/structure-2x.png)

# Participants

- Facade (`Compiler`)
    - 요청을 처리할 책임이 있는 하위 시스템 클래스가 무엇인지 알고 있음
    - 클라이언트 요청을 적절한 하위 시스템 객체에 위임
- 하위 시스템 클래스 (`Scanner`, `Parser`, `ProgramNode` 등)
    - 하위 시스템 기능을 구현
    - Facade 객체에 의해 할당된 작업을 처리
    - Facade를 모름; Facade에 대한 참조를 유지하지 않음

# Collaborations

- 클라이언트는 Facade에 요청을 보내는 방식으로 하위 시스템과 통신하며, Facade는 이를 적절한 하위 시스템 객체(들)에 전달
- 하위 시스템 객체들이 실제 작업을 수행하지만, Facade는 자신의 인터페이스를 하위 시스템 인터페이스로 변환하기 위한 자체적인 작업을 수행해야 할 수도 있음
- Facade를 사용하는 클라이언트는 하위 시스템 객체에 직접 접근할 필요가 없음

# Consequences

1. 클라이언트 코드 단순화
    - 클라이언트가 다루는 객체 수를 줄여 하위 시스템 사용이 간편해짐
    - 복잡한 하위 시스템을 간단한 인터페이스로 추상화
2. 느슨한 결합(Weak Coupling) 촉진
    - 하위 시스템과 클라이언트 간의 의존성 감소
    - 하위 시스템 내부 변경이 클라이언트에 영향을 미치지 않음
    - 복잡하거나 순환적인 의존성 제거
3. 컴파일 의존성 감소
    - 하위 시스템 변경 시 재컴파일 필요성 최소화
    - 개발 및 빌드 시간 단축
    - 다른 플랫폼으로의 이식성 향상
4. 유연성 유지
    - 필요한 경우 클라이언트가 직접 하위 시스템 클래스에 접근 가능
    - 사용 편의성과 일반성(세부 기능 접근) 사이의 균형 제공

# Implementation

1. 클라이언트-하위 시스템 결합도 감소 전략
    - 추상 Facade 클래스 활용: Facade를 추상 클래스로 만들고 다양한 하위 시스템 구현을 위한 구체적 하위 클래스 제공
        - 클라이언트는 추상 Facade 인터페이스를 통해 통신하므로 실제 어떤 하위 시스템 구현이 사용되는지 알 필요 없음
    - 설정 가능한 Facade: 다양한 하위 시스템 객체들로 Facade를 구성
        - 필요에 따라 하위 시스템 객체를 교체하여 Facade 커스터마이징 가능
2. 공개(Public)와 비공개(Private) 하위 시스템 클래스 구분
    - 하위 시스템의 인터페이스 개념: 클래스가 상태와 연산을 캡슐화하듯이, 하위 시스템은 클래스들을 캡슐화
        - 클래스와 마찬가지로 하위 시스템에도 공개 및 비공개 인터페이스 개념 적용 가능
    - 공개 인터페이스: 모든 클라이언트가 접근할 수 있는 클래스들(Facade 포함)
    - 비공개 인터페이스: 하위 시스템 확장자만을 위한 클래스들

## 추가로?

1. Facade는 단순한 전달자(delegate)에 그치지 않고 다음과 같은 역할을 수행할 수 있음:
    - 하위 시스템 호출 순서 조정
    - 여러 하위 시스템의 출력 결과 종합
    - 클라이언트 요청을 하위 시스템이 이해할 수 있는 형식으로 변환

이를테면:

```
[Client]
   ↓
[CompilerFacade]
   ↓
Scanner → Parser → CodeGenerator
```

2. Facade가 a god object(만능객체)로 전락할 수도 있음
    - 한 번에 할 거 하나만 딱 정하고 더 커진다 싶으면 더 정제된 파사드를 만들거나
    - MEDIATOR를 고려하거나.

# Sample Code

`facade/src`, `facade/test` 참조

# Known usages

# Related patterns

- ABSTRACT FACTORY
    - Facade와 함께 사용하여 하위 시스템 독립적인 방식으로 하위 시스템 객체를 생성하기 위한 인터페이스를 제공할 수 있음
    - 추상 팩토리는 또한 플랫폼 특정 클래스를 숨기기 위한 Facade의 대안으로도 사용 가능
- MEDIATOR
    - 기존 클래스의 기능을 추상화한다는 점에서 Facade와 유사
    - MEDIATOR의 목적은 동료(colleague) 객체 간의 임의적인 통신을 추상화하는 것으로, 종종 어느 하나에도 속하지 않는 기능을 중앙화합니다. MEDIATOR의 동료들은
      MEDIATOR를 인식하고 서로 직접 통신하는 대신 MEDIATOR와 통신
    - Facade는 단지 사용하기 쉽게 만들기 위해 하위 시스템 객체에 대한 인터페이스를 추상화; 새로운 기능을 정의하지 않으며, 하위 시스템 클래스들은 Facade에 대해 알지 못함

일반적으로 하나의 Facade 객체만 필요하기 때문에, Facade 객체는 보통 SINGLETON으로 쓰임
